<!DOCTYPE html>
<html lang="nb">
<head>
  <meta charset="UTF-8" />
  <title>NorTopicStats</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Trimble Connect Workspace API -->
  <script src="https://components.connect.trimble.com/trimble-connect-workspace-api/index.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    :root{
      --primary:#0069d9;
      --border:#e5e7eb;
      --card:#ffffff;
      --bg:#f5f5f7;
      --text:#111827;
      --muted:#6b7280;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body{ margin:0; background:var(--bg); color:var(--text); min-height:100vh; display:flex; flex-direction:column; }

    header{
      display:flex; align-items:center; gap:14px;
      padding:12px 14px; background:var(--card); border-bottom:1px solid var(--border);
    }
    .logoBox{
      width:92px; height:92px; border-radius:12px; background:#fff; border:1px solid #eee;
      display:flex; align-items:center; justify-content:center; overflow:hidden;
      box-shadow:0 1px 3px rgba(15,23,42,.08); flex:0 0 auto;
    }
    .logoBox img{ width:84px; height:84px; object-fit:contain; display:block; }

    .titleBlock{ display:flex; flex-direction:column; gap:2px; }
    .title{ font-weight:800; font-size:18px; color:var(--primary); line-height:1.1; }
    .org{ font-weight:700; font-size:13px; opacity:.9; }
    .dev{ font-size:11px; opacity:.75; font-style:italic; }

    .headerRight{
      margin-left:auto; display:flex; align-items:center; gap:10px; flex-wrap:wrap; justify-content:flex-end;
    }
    #status{
      font-size:12px; opacity:.85; white-space:nowrap; max-width:520px; overflow:hidden; text-overflow:ellipsis;
    }

    button{
      padding:8px 10px; border-radius:8px; border:1px solid var(--primary);
      background:var(--primary); color:#fff; font-size:13px; font-weight:600; cursor:pointer;
      box-shadow:0 1px 2px rgba(0,0,0,.08);
    }
    button.secondary{ border:1px solid #777; background:#777; }
    button:disabled{ opacity:.6; cursor:default; }

    .loading-spinner{
      display:inline-block; width:12px; height:12px; border-radius:50%;
      border:2px solid #ccc; border-top-color:var(--primary);
      animation:spin .8s linear infinite; margin-right:6px; vertical-align:-2px;
    }
    @keyframes spin{ to{ transform:rotate(360deg);} }

    main{
      flex:1; display:flex; flex-direction:column; padding:12px 14px 18px 14px; gap:12px; overflow:auto;
    }
    #error{ font-size:13px; color:#b00020; white-space:pre-wrap; }

    .filterRow{
      display:flex;
      gap:10px;
      align-items:flex-end;
      flex-wrap:wrap;
      padding:10px 12px;
      background:var(--card);
      border:1px solid var(--border);
      border-radius:14px;
    }
    .field{ display:flex; flex-direction:column; gap:4px; }
    .field label{ font-size:12px; color:var(--muted); font-weight:700; }
    select{
      padding:8px 10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#fff;
      font-size:13px;
      min-width:220px;
    }
    .hint{ font-size:12px; color:var(--muted); margin-left:auto; }

    .sectionTitle{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      background:var(--card);
      border:1px solid var(--border);
      border-radius:14px;
      font-weight:900;
    }
    .sectionTitle small{ font-weight:700; color:var(--muted); }

    .cards{
      display:grid;
      grid-template-columns:repeat(auto-fit, minmax(360px, 1fr));
      gap:0;
      border:1px solid var(--border);
      border-radius:14px;
      overflow:hidden;
      background:var(--card);
    }
    .card{
      background:var(--card);
      padding:12px 12px 14px 12px;
      display:flex;
      flex-direction:column;
      min-height:280px;
      border-right:1px solid var(--border);
      border-bottom:1px solid var(--border);
    }
    .card h2{ margin:0 0 8px 0; font-size:14px; font-weight:800; }
    .divider{ height:1px; background:var(--border); margin:8px 0 10px 0; }
    .small-text{ font-size:12px; color:var(--muted); margin-top:8px; }
    canvas{ width:100% !important; height:280px !important; }

    .tableWrap{
      margin-top:10px;
      border:1px solid var(--border);
      border-radius:12px;
      overflow:auto;
      background:#fff;
    }
    table{
      width:100%;
      border-collapse:collapse;
      min-width:560px;
    }
    th, td{
      padding:8px 10px;
      border-bottom:1px solid var(--border);
      font-size:12px;
      text-align:left;
      white-space:nowrap;
    }
    th{
      position:sticky;
      top:0;
      background:#fafafa;
      z-index:1;
      font-weight:900;
    }
    tr:last-child td{ border-bottom:0; }
    .right{ text-align:right; }
    .pill{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid var(--border);
      background:#f8fafc;
      font-weight:700;
    }
  </style>
</head>

<body>
  <header>
    <div class="logoBox">
      <img src="norconsult-logo-black.png" alt="Norconsult logo"
           onerror="this.style.display='none'; this.parentElement.textContent='Norconsult'; this.parentElement.style.fontWeight='900';">
    </div>

    <div class="titleBlock">
      <div class="title">NorTopicStats</div>
      <div class="org">Norconsult Norge</div>
      <div class="dev">Developed by Edin Dzakmic, Norconsult, (AI-assisted development)</div>
    </div>

    <div class="headerRight">
      <div id="status"><span class="loading-spinner"></span>Kobler til Trimble Connect…</div>
      <button id="refreshBtn">Oppdater data</button>
    </div>
  </header>

  <main>
    <div id="error"></div>

    <div class="filterRow">
      <div class="field">
        <label for="fromWeekSelect">Fra uke</label>
        <select id="fromWeekSelect"><option value="">(ingen)</option></select>
      </div>

      <div class="field">
        <label for="toWeekSelect">Til uke</label>
        <select id="toWeekSelect"><option value="">(ingen)</option></select>
      </div>

      <button class="secondary" id="applyWeekBtn">Bruk ukeintervall</button>

      <div class="hint">Hvis “Fra” og “Til” er tomme → alle uker.</div>
    </div>

    <!-- ===== VDC DASHBOARD ===== -->
    <div class="sectionTitle">
      VDC dashboard
      <small>Flow • WIP • Backlog • Aging • Cycle time • CFD • Aging per fag</small>
    </div>

    <div class="cards">
      <div class="card">
        <h2>Created vs Closed (per uke)</h2>
        <div class="divider"></div>
        <canvas id="createdClosedChart"></canvas>
        <div class="small-text">Closed-uke estimeres med <code>modified_date</code> når status er lukket.</div>
      </div>

      <div class="card">
        <h2>Backlog (kumulativ)</h2>
        <div class="divider"></div>
        <canvas id="backlogChart"></canvas>
        <div class="small-text">Kumulativt (Created − Closed).</div>
      </div>

      <div class="card">
        <h2>WIP over tid</h2>
        <div class="divider"></div>
        <canvas id="wipChart"></canvas>
        <div class="small-text">Åpne saker ved slutten av hver uke.</div>
      </div>

      <div class="card">
        <h2>Aging (åpne saker)</h2>
        <div class="divider"></div>
        <canvas id="agingChart"></canvas>
        <div class="small-text">Aldersfordeling for åpne saker ved periodens slutt.</div>
      </div>

      <div class="card">
        <h2>Cycle time (Median + P80)</h2>
        <div class="divider"></div>
        <canvas id="cycleTimeChart"></canvas>
        <div class="small-text">Basert på lukkede saker: <code>modified_date - creation_date</code>.</div>
      </div>

      <div class="card">
        <h2>Due date: On-time vs Late</h2>
        <div class="divider"></div>
        <canvas id="dueDateChart"></canvas>
        <div class="small-text" id="dueDateNote">Vises kun hvis <code>due_date</code> finnes.</div>
      </div>

      <!-- NEW: CFD -->
      <div class="card">
        <h2>Cumulative Flow Diagram (CFD)</h2>
        <div class="divider"></div>
        <canvas id="cfdChart"></canvas>
        <div class="small-text">
          OBS: Uten status-historikk er dette en <b>approksimasjon</b>. Vi estimerer “Closed” fra <code>modified_date</code>,
          og resterende saker regnes som åpne (fordelt på nåværende status).
        </div>
      </div>

      <!-- NEW: Aging per fag -->
      <div class="card">
        <h2>Alder per fag (Tag) – åpne saker</h2>
        <div class="divider"></div>
        <canvas id="agingByTagChart"></canvas>
        <div class="small-text">
          Stacked buckets per fag (Tag) ved periodens slutt: 0–7, 8–14, 15–30, 31–60, 60+ dager.
        </div>
      </div>
    </div>

    <!-- ===== TOPIC DASHBOARD ===== -->
    <div class="sectionTitle">
      Topic dashboard
      <small>Opprettet • Status/Type/Priority • Fag (Tag) • Cycle time</small>
    </div>

    <div class="cards">
      <div class="card">
        <h2>Opprettede Topics over tid</h2>
        <div class="divider"></div>
        <canvas id="createdOverTimeChart"></canvas>
      </div>

      <div class="card">
        <h2>Topics per Status over tid (linje)</h2>
        <div class="divider"></div>
        <canvas id="statusLineChart"></canvas>
      </div>

      <div class="card">
        <h2>Topics per Type over tid (linje)</h2>
        <div class="divider"></div>
        <canvas id="typeLineChart"></canvas>
      </div>

      <div class="card">
        <h2>Topics per Priority over tid (linje)</h2>
        <div class="divider"></div>
        <canvas id="priorityLineChart"></canvas>
      </div>

      <div class="card">
        <h2>Fag (Tag): antall saker + statusoversikt</h2>
        <div class="divider"></div>
        <canvas id="tagDisciplineChart"></canvas>
        <div class="tableWrap" id="tagStatusTableWrap"></div>
      </div>

      <div class="card">
        <h2>Gjennomsnittlig tid fra opprettet → lukket</h2>
        <div class="divider"></div>
        <canvas id="avgCycleTimeChart"></canvas>
      </div>
    </div>
  </main>

  <script>
    // ====== KONFIG ======
    const TOPICS_API_BASE = "https://open21.connect.trimble.com";
    const CLOSED_STATUSES = new Set(["Closed", "Done", "Resolved", "Approved"]);
    const UNKNOWN_LABEL = "Ikke satt";

    // Buckets for aging
    const AGING_BUCKETS = [
      { key: "0-7",  min: 0,  max: 7 },
      { key: "8-14", min: 8,  max: 14 },
      { key: "15-30",min: 15, max: 30 },
      { key: "31-60",min: 31, max: 60 },
      { key: "60+",  min: 61, max: Infinity }
    ];

    // STATE
    let API=null, accessToken=null, currentProjectId=null;
    let allTopics=[], allTopicsWithDates=[];

    // VDC charts
    let createdClosedChart=null, backlogChart=null, wipChart=null, agingChart=null, cycleTimeChart=null, dueDateChart=null;
    let cfdChart=null, agingByTagChart=null;

    // Topic charts
    let createdOverTimeChart=null, statusLineChart=null, typeLineChart=null, priorityLineChart=null, tagDisciplineChart=null, avgCycleTimeChart=null;

    // ====== HELPERS ======
    function escapeHtml(str){return String(str??"").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;").replaceAll("'","&#039;");}
    function setStatus(message,isLoading=false){
      const el=document.getElementById("status");
      el.innerHTML=isLoading?`<span class="loading-spinner"></span>${escapeHtml(message)}`:escapeHtml(message);
    }
    function setError(message){document.getElementById("error").textContent=message||"";}
    function setBusy(isBusy){document.getElementById("refreshBtn").disabled=isBusy;}

    function safeStr(v){return (v===null||v===undefined)?"":String(v).trim();}
    function parseDateMaybe(v){const s=safeStr(v); if(!s) return null; const d=new Date(s); return Number.isNaN(d.getTime())?null:d;}
    function pad2(n){return String(n).padStart(2,"0");}

    // ISO week key: YYYY-Www
    function getISOWeekKey(date){
      const d=new Date(Date.UTC(date.getFullYear(),date.getMonth(),date.getDate()));
      const dayNum=d.getUTCDay()||7;
      d.setUTCDate(d.getUTCDate()+4-dayNum);
      const yearStart=new Date(Date.UTC(d.getUTCFullYear(),0,1));
      const weekNo=Math.ceil((((d-yearStart)/86400000)+1)/7);
      return `${d.getUTCFullYear()}-W${pad2(weekNo)}`;
    }
    function bucketKey(date){return getISOWeekKey(date);}
    function compareWeekKeys(a,b){return a.localeCompare(b);}
    function uniqueSorted(arr){return [...new Set(arr)].sort((a,b)=>a.localeCompare(b));}

    // week range: start/end (UTC)
    function isoWeekToDateRange(weekKey){
      const [yPart,wPart]=weekKey.split("-W");
      const year=Number(yPart), week=Number(wPart);
      const jan4=new Date(Date.UTC(year,0,4));
      const dayNum=jan4.getUTCDay()||7;
      const mondayWeek1=new Date(jan4);
      mondayWeek1.setUTCDate(jan4.getUTCDate()-(dayNum-1));
      const start=new Date(mondayWeek1);
      start.setUTCDate(mondayWeek1.getUTCDate()+(week-1)*7);
      start.setUTCHours(0,0,0,0);
      const end=new Date(start);
      end.setUTCDate(start.getUTCDate()+6);
      end.setUTCHours(23,59,59,999);
      return {start,end};
    }

    function avg(nums){const v=nums.filter(Number.isFinite); if(!v.length) return null; return v.reduce((a,b)=>a+b,0)/v.length;}
    function median(nums){
      const v=nums.filter(Number.isFinite).sort((a,b)=>a-b);
      if(!v.length) return null;
      const mid=Math.floor(v.length/2);
      return v.length%2?v[mid]:(v[mid-1]+v[mid])/2;
    }
    function percentile(nums,p){
      const v=nums.filter(Number.isFinite).sort((a,b)=>a-b);
      if(!v.length) return null;
      const idx=(v.length-1)*p;
      const lo=Math.floor(idx), hi=Math.ceil(idx);
      if(lo===hi) return v[lo];
      return v[lo]+(v[hi]-v[lo])*(idx-lo);
    }

    function getClosedDateIfClosed(topic){
      const st=safeStr(topic.topic_status||topic.status);
      if(!CLOSED_STATUSES.has(st)) return null;
      return parseDateMaybe(topic.modified_date);
    }

    // ====== FILTER UI ======
    function populateWeekRangeSelectors(topics){
      const weeks=[];
      for(const t of topics){
        const cd=parseDateMaybe(t.creation_date); if(cd) weeks.push(bucketKey(cd));
        const closed=getClosedDateIfClosed(t); if(closed) weeks.push(bucketKey(closed));
      }
      const uniqueWeeks=uniqueSorted(weeks);

      const fromSel=document.getElementById("fromWeekSelect");
      const toSel=document.getElementById("toWeekSelect");
      const prevFrom=fromSel.value, prevTo=toSel.value;

      fromSel.innerHTML=`<option value="">(ingen)</option>`+uniqueWeeks.map(w=>`<option value="${escapeHtml(w)}">${escapeHtml(w)}</option>`).join("");
      toSel.innerHTML=`<option value="">(ingen)</option>`+uniqueWeeks.map(w=>`<option value="${escapeHtml(w)}">${escapeHtml(w)}</option>`).join("");

      if(prevFrom && uniqueWeeks.includes(prevFrom)) fromSel.value=prevFrom;
      if(prevTo && uniqueWeeks.includes(prevTo)) toSel.value=prevTo;
    }

    function filterTopicsByWeekRange(topics){
      const from=document.getElementById("fromWeekSelect").value;
      const to=document.getElementById("toWeekSelect").value;
      if(!from && !to) return topics;

      return topics.filter(t=>{
        const cd=parseDateMaybe(t.creation_date);
        if(!cd) return false;
        const wk=bucketKey(cd);
        if(from && compareWeekKeys(wk,from)<0) return false;
        if(to && compareWeekKeys(wk,to)>0) return false;
        return true;
      });
    }

    function getPeriodEndDateFromSelection(weekLabelsSorted){
      const to=document.getElementById("toWeekSelect").value;
      if(to) return isoWeekToDateRange(to).end;
      const last=weekLabelsSorted.length?weekLabelsSorted[weekLabelsSorted.length-1]:null;
      return last?isoWeekToDateRange(last).end:new Date();
    }

    // ====== TAGS ======
    function extractTags(topic){
      const candidates=[];
      if(Array.isArray(topic.labels)) candidates.push(...topic.labels);
      if(Array.isArray(topic.tags)) candidates.push(...topic.tags);
      const single=safeStr(topic.label||topic.tag||topic.discipline);
      if(single) candidates.push(single);
      return [...new Set(candidates.map(safeStr).filter(Boolean))];
    }
    function getTopicStatus(topic){return safeStr(topic.topic_status||topic.status)||UNKNOWN_LABEL;}

    // ====== AGG: TOPIC DASHBOARD ======
    function aggregateCreatedTotal(topics){
      const buckets=[]; const bucketMap=new Map();
      for(const t of topics){
        const cd=parseDateMaybe(t.creation_date); if(!cd) continue;
        const b=bucketKey(cd); buckets.push(b);
        bucketMap.set(b,(bucketMap.get(b)||0)+1);
      }
      const labels=uniqueSorted(buckets);
      const totals=labels.map(b=>bucketMap.get(b)||0);
      return {labels,totals};
    }

    function aggregateCreatedByCategory(topics,getCategory){
      const buckets=[]; const bucketMap=new Map();
      for(const t of topics){
        const cd=parseDateMaybe(t.creation_date); if(!cd) continue;
        const b=bucketKey(cd); buckets.push(b);
        const cat=safeStr(getCategory(t))||UNKNOWN_LABEL;
        if(!bucketMap.has(b)) bucketMap.set(b,{});
        bucketMap.get(b)[cat]=(bucketMap.get(b)[cat]||0)+1;
      }
      const labels=uniqueSorted(buckets);
      const keySet=new Set();
      for(const b of labels){
        const obj=bucketMap.get(b)||{};
        Object.keys(obj).forEach(k=>keySet.add(k));
      }
      const keys=[...keySet].sort((a,b)=>a.localeCompare(b));
      const seriesMap={};
      for(const k of keys) seriesMap[k]=labels.map(b=>bucketMap.get(b)?.[k]||0);
      return {labels,keys,seriesMap};
    }

    function aggregateTagCounts(topics){
      const counts={};
      for(const t of topics){
        const tags=extractTags(t);
        const used=tags.length?tags:[UNKNOWN_LABEL];
        for(const tag of used) counts[tag]=(counts[tag]||0)+1;
      }
      return counts;
    }

    function aggregateTagStatusMatrix(topics){
      const matrix={}, totals={}, statusSet=new Set();
      for(const t of topics){
        const status=getTopicStatus(t);
        statusSet.add(status);
        const tags=extractTags(t);
        const used=tags.length?tags:[UNKNOWN_LABEL];
        for(const tag of used){
          if(!matrix[tag]) matrix[tag]={};
          matrix[tag][status]=(matrix[tag][status]||0)+1;
          totals[tag]=(totals[tag]||0)+1;
        }
      }
      const tags=Object.keys(matrix).sort((a,b)=>a.localeCompare(b));
      const statuses=[...statusSet].sort((a,b)=>a.localeCompare(b));
      return {tags,statuses,matrix,totals};
    }

    function renderTagStatusTable(targetEl, tagMatrix){
      const {tags,statuses,matrix,totals}=tagMatrix;
      const header=`<th>Fag (Tag)</th><th class="right">Totalt</th>`+statuses.map(s=>`<th class="right">${escapeHtml(s)}</th>`).join("");
      const rows=tags.map(tag=>{
        const total=totals[tag]||0;
        const cells=`<td><span class="pill">${escapeHtml(tag)}</span></td><td class="right"><b>${total}</b></td>`+
          statuses.map(s=>`<td class="right">${matrix[tag]?.[s]||0}</td>`).join("");
        return `<tr>${cells}</tr>`;
      }).join("");
      targetEl.innerHTML=`<table><thead><tr>${header}</tr></thead><tbody>${rows}</tbody></table>`;
    }

    function aggregateAvgCycleTimeCreationBucket(topics){
      const bucketMap=new Map(); const allDays=[];
      for(const t of topics){
        const closed=getClosedDateIfClosed(t);
        if(!closed) continue;
        const cd=parseDateMaybe(t.creation_date); if(!cd) continue;
        const diff=closed.getTime()-cd.getTime(); if(diff<0) continue;
        const days=diff/(1000*60*60*24);
        allDays.push(days);
        const b=bucketKey(cd);
        if(!bucketMap.has(b)) bucketMap.set(b,[]);
        bucketMap.get(b).push(days);
      }
      const labels=uniqueSorted([...bucketMap.keys()]);
      const series=labels.map(b=>{const a=avg(bucketMap.get(b)||[]); return a===null?null:Math.round(a);});
      const globalAvg=avg(allDays);
      const globalLine=labels.map(_=>globalAvg===null?null:Math.round(globalAvg));
      return {labels,series,globalLine};
    }

    // ====== AGG: VDC DASHBOARD ======
    function buildUnifiedWeekLabels(topics){
      const weeks=[];
      for(const t of topics){
        const cd=parseDateMaybe(t.creation_date); if(cd) weeks.push(bucketKey(cd));
        const closed=getClosedDateIfClosed(t); if(closed) weeks.push(bucketKey(closed));
      }
      return uniqueSorted(weeks).sort(compareWeekKeys);
    }

    function aggregateCreatedClosedPerWeek(topics, weekLabels){
      const createdMap={}, closedMap={};
      for(const w of weekLabels){ createdMap[w]=0; closedMap[w]=0; }

      for(const t of topics){
        const cd=parseDateMaybe(t.creation_date);
        if(cd){
          const w=bucketKey(cd);
          if(w in createdMap) createdMap[w]+=1;
        }
        const closed=getClosedDateIfClosed(t);
        if(closed){
          const w=bucketKey(closed);
          if(w in closedMap) closedMap[w]+=1;
        }
      }
      return {
        createdSeries: weekLabels.map(w=>createdMap[w]||0),
        closedSeries: weekLabels.map(w=>closedMap[w]||0)
      };
    }

    function aggregateBacklogCumulative(createdSeries, closedSeries){
      const out=[]; let cum=0;
      for(let i=0;i<createdSeries.length;i++){
        cum += (createdSeries[i]||0) - (closedSeries[i]||0);
        out.push(cum);
      }
      return out;
    }

    function aggregateWipEndOfWeek(topics, weekLabels){
      const items=topics.map(t=>{
        const created=parseDateMaybe(t.creation_date);
        const closed=getClosedDateIfClosed(t);
        return {created,closed};
      }).filter(x=>x.created);

      const out=[];
      for(const w of weekLabels){
        const {end}=isoWeekToDateRange(w);
        const endMs=end.getTime();
        let count=0;
        for(const it of items){
          if(it.created.getTime()<=endMs){
            if(!it.closed || it.closed.getTime()>endMs) count++;
          }
        }
        out.push(count);
      }
      return out;
    }

    function aggregateAgingOpenBuckets(topics, periodEndDate){
      const buckets={}; for(const b of AGING_BUCKETS) buckets[b.key]=0;
      const endMs=periodEndDate.getTime();

      for(const t of topics){
        const created=parseDateMaybe(t.creation_date);
        if(!created) continue;

        const closed=getClosedDateIfClosed(t);
        const openAtEnd=!closed || closed.getTime()>endMs;
        if(!openAtEnd) continue;

        const ageDays=Math.floor((endMs-created.getTime())/(1000*60*60*24));
        for(const b of AGING_BUCKETS){
          if(ageDays>=b.min && ageDays<=b.max){ buckets[b.key]+=1; break; }
        }
      }
      return buckets;
    }

    function aggregateCycleTimeMedianP80ByCloseWeek(topics, weekLabels){
      const map={}; for(const w of weekLabels) map[w]=[];
      for(const t of topics){
        const created=parseDateMaybe(t.creation_date);
        const closed=getClosedDateIfClosed(t);
        if(!created || !closed) continue;
        const diff=closed.getTime()-created.getTime(); if(diff<0) continue;
        const days=diff/(1000*60*60*24);
        const w=bucketKey(closed);
        if(w in map) map[w].push(days);
      }
      return {
        medianSeries: weekLabels.map(w=>{const m=median(map[w]||[]); return m===null?null:Math.round(m);}),
        p80Series: weekLabels.map(w=>{const p=percentile(map[w]||[],0.80); return p===null?null:Math.round(p);})
      };
    }

    function extractDueDate(topic){ return parseDateMaybe(topic.due_date || topic.dueDate || topic.duedate); }

    function aggregateDueDateOnTimeLateByCloseWeek(topics, weekLabels){
      const onTime={}, late={};
      for(const w of weekLabels){ onTime[w]=0; late[w]=0; }
      let foundAnyDue=false;

      for(const t of topics){
        const due=extractDueDate(t);
        if(!due) continue;
        foundAnyDue=true;
        const closed=getClosedDateIfClosed(t);
        if(!closed) continue;

        const w=bucketKey(closed);
        if(!(w in onTime)) continue;
        if(closed.getTime()<=due.getTime()) onTime[w]+=1;
        else late[w]+=1;
      }

      return {
        foundAnyDue,
        onTimeSeries: weekLabels.map(w=>onTime[w]||0),
        lateSeries: weekLabels.map(w=>late[w]||0)
      };
    }

    // ====== NEW: CFD (approx) ======
    function aggregateCfdApprox(topics, weekLabels){
      // We estimate a minimal CFD using available timestamps:
      // - "Closed" count at weekEnd: topics closed on/before weekEnd (based on modified_date).
      // - All others that exist by weekEnd are grouped by their CURRENT status (snapshot at now).
      //
      // This is NOT a true CFD without status history, but gives a useful "shape":
      // total grows with created; closed grows with closures; remaining stack splits by current status.

      const statusesSet=new Set();
      for(const t of topics){
        const st=getTopicStatus(t);
        if(!CLOSED_STATUSES.has(st)) statusesSet.add(st);
      }
      // ensure stable order
      const openStatuses=[...statusesSet].sort((a,b)=>a.localeCompare(b));

      const seriesMap={};
      for(const st of openStatuses) seriesMap[st]=[];
      seriesMap["Closed"]=[];

      const items=topics.map(t=>{
        const created=parseDateMaybe(t.creation_date);
        const closed=getClosedDateIfClosed(t); // may be null
        const status=getTopicStatus(t);
        return {created,closed,status};
      }).filter(x=>x.created);

      for(const w of weekLabels){
        const {end}=isoWeekToDateRange(w);
        const endMs=end.getTime();

        // counts
        let closedCount=0;
        const openCountByStatus={};
        for(const st of openStatuses) openCountByStatus[st]=0;

        for(const it of items){
          if(it.created.getTime()>endMs) continue; // not yet created

          if(it.closed && it.closed.getTime()<=endMs){
            closedCount++;
          } else {
            // open at endMs; categorize by CURRENT status (approx)
            const st = (CLOSED_STATUSES.has(it.status) ? "Open" : it.status);
            if(st in openCountByStatus) openCountByStatus[st] += 1;
            else {
              // if status is missing/new
              if(!openCountByStatus[UNKNOWN_LABEL]) openCountByStatus[UNKNOWN_LABEL]=0;
              openCountByStatus[UNKNOWN_LABEL] += 1;
            }
          }
        }

        for(const st of openStatuses){
          seriesMap[st].push(openCountByStatus[st]||0);
        }
        seriesMap["Closed"].push(closedCount);
      }

      const keys=[...openStatuses, "Closed"];
      return { keys, seriesMap };
    }

    // ====== NEW: Aging per Tag (open items) ======
    function aggregateAgingOpenBucketsByTag(topics, periodEndDate){
      // returns { tags:[...], buckets:[...], seriesMap:{bucketKey:[counts per tag]} } for stacked bar
      const endMs=periodEndDate.getTime();

      // tag -> bucketKey -> count
      const tagMap={};

      for(const t of topics){
        const created=parseDateMaybe(t.creation_date);
        if(!created) continue;

        const closed=getClosedDateIfClosed(t);
        const openAtEnd=!closed || closed.getTime()>endMs;
        if(!openAtEnd) continue;

        const tags=extractTags(t);
        const used=tags.length?tags:[UNKNOWN_LABEL];

        const ageDays=Math.floor((endMs-created.getTime())/(1000*60*60*24));
        let bucket = "60+";
        for(const b of AGING_BUCKETS){
          if(ageDays>=b.min && ageDays<=b.max){ bucket=b.key; break; }
        }

        for(const tag of used){
          if(!tagMap[tag]) tagMap[tag]={};
          tagMap[tag][bucket]=(tagMap[tag][bucket]||0)+1;
        }
      }

      const tags=Object.keys(tagMap).sort((a,b)=>a.localeCompare(b));
      const buckets=AGING_BUCKETS.map(b=>b.key);

      // build per bucket arrays aligned to tags
      const seriesMap={};
      for(const b of buckets){
        seriesMap[b]=tags.map(tag => tagMap[tag]?.[b] || 0);
      }

      return { tags, buckets, seriesMap };
    }

    // ====== CHART BUILDERS ======
    function destroyIf(c){ if(c) c.destroy(); return null; }

    function buildBar(ctx, labels, datasets, stacked=false){
      return new Chart(ctx,{
        type:"bar",
        data:{labels,datasets},
        options:{
          responsive:true,
          plugins:{legend:{display:true}},
          scales:{
            x:{stacked, ticks:{maxRotation:45,minRotation:0,autoSkip:true}},
            y:{stacked, beginAtZero:true, ticks:{precision:0}}
          }
        }
      });
    }

    function buildLine(ctx, labels, datasets){
      return new Chart(ctx,{
        type:"line",
        data:{labels,datasets},
        options:{
          responsive:true,
          plugins:{legend:{display:true}},
          scales:{
            x:{ticks:{maxRotation:45,minRotation:0,autoSkip:true}},
            y:{beginAtZero:true, ticks:{precision:0}}
          }
        }
      });
    }

    function buildMultiLine(ctx, labels, keys, seriesMap){
      const datasets=keys.map(k=>({
        label:k,
        data:seriesMap[k],
        tension:0.25,
        pointRadius:2
      }));
      return buildLine(ctx, labels, datasets);
    }

    function buildPieWithCounts(ctx, counts){
      const labels=Object.keys(counts);
      const data=labels.map(l=>counts[l]);
      return new Chart(ctx,{
        type:"pie",
        data:{labels,datasets:[{data}]},
        options:{
          responsive:true,
          plugins:{
            legend:{display:true},
            tooltip:{callbacks:{label:(c)=>`${c.label}: ${c.parsed??0}`}}
          }
        }
      });
    }

    function buildStackedBar(ctx, labels, buckets, seriesMap){
      const datasets=buckets.map(b=>({
        label:b,
        data:seriesMap[b]
      }));
      return buildBar(ctx, labels, datasets, true);
    }

    function buildCfd(ctx, labels, keys, seriesMap){
      // stacked area using line chart with fill
      const datasets = keys.map((k, idx) => ({
        label: k,
        data: seriesMap[k],
        fill: idx === 0 ? "origin" : "-1",
        tension: 0.25,
        pointRadius: 0
      }));
      return new Chart(ctx,{
        type:"line",
        data:{labels,datasets},
        options:{
          responsive:true,
          plugins:{legend:{display:true}},
          scales:{
            x:{ticks:{maxRotation:45,minRotation:0,autoSkip:true}},
            y:{beginAtZero:true, ticks:{precision:0}}
          }
        }
      });
    }

    // ====== API ======
    async function fetchTopics(projectId){
      if(!accessToken) throw new Error("Mangler accessToken – kunne ikke hente Topics.");
      const url=`${TOPICS_API_BASE}/bcf/3.0/projects/${encodeURIComponent(projectId)}/topics`;

      const resp=await fetch(url,{
        method:"GET",
        headers:{ "Authorization":`Bearer ${accessToken}`, "Accept":"application/json" }
      });

      if(!resp.ok){
        const text=await resp.text().catch(()=> "");
        throw new Error(`Topics API-feil (${resp.status}): ${text || resp.statusText}`);
      }

      const json=await resp.json();
      return Array.isArray(json)?json:[];
    }

    // ====== RENDER ======
    function renderVdcDashboard(topicsToUse){
      const weekLabels = buildUnifiedWeekLabels(topicsToUse);
      if(!weekLabels.length) return;

      const periodEndDate = getPeriodEndDateFromSelection(weekLabels);

      // Created vs Closed
      const cc=aggregateCreatedClosedPerWeek(topicsToUse, weekLabels);
      createdClosedChart=destroyIf(createdClosedChart);
      createdClosedChart=buildBar(
        document.getElementById("createdClosedChart").getContext("2d"),
        weekLabels,
        [{label:"Created",data:cc.createdSeries},{label:"Closed",data:cc.closedSeries}],
        false
      );

      // Backlog cumulative
      const backlogSeries=aggregateBacklogCumulative(cc.createdSeries, cc.closedSeries);
      backlogChart=destroyIf(backlogChart);
      backlogChart=buildLine(
        document.getElementById("backlogChart").getContext("2d"),
        weekLabels,
        [{label:"Backlog (kumulativ)",data:backlogSeries,tension:0.25,pointRadius:2}]
      );

      // WIP
      const wipSeries=aggregateWipEndOfWeek(topicsToUse, weekLabels);
      wipChart=destroyIf(wipChart);
      wipChart=buildLine(
        document.getElementById("wipChart").getContext("2d"),
        weekLabels,
        [{label:"WIP (åpne ved ukeslutt)",data:wipSeries,tension:0.25,pointRadius:2}]
      );

      // Aging
      const aging=aggregateAgingOpenBuckets(topicsToUse, periodEndDate);
      agingChart=destroyIf(agingChart);
      agingChart=buildBar(
        document.getElementById("agingChart").getContext("2d"),
        Object.keys(aging),
        [{label:"Åpne saker", data:Object.keys(aging).map(k=>aging[k])}],
        false
      );

      // Cycle time median + P80 (close-week)
      const ct=aggregateCycleTimeMedianP80ByCloseWeek(topicsToUse, weekLabels);
      cycleTimeChart=destroyIf(cycleTimeChart);
      cycleTimeChart=buildLine(
        document.getElementById("cycleTimeChart").getContext("2d"),
        weekLabels,
        [
          {label:"Median (dager)",data:ct.medianSeries,tension:0.25,pointRadius:2},
          {label:"P80 (dager)",data:ct.p80Series,tension:0.25,pointRadius:2}
        ]
      );

      // Due date
      const dd=aggregateDueDateOnTimeLateByCloseWeek(topicsToUse, weekLabels);
      const note=document.getElementById("dueDateNote");
      dueDateChart=destroyIf(dueDateChart);

      if(!dd.foundAnyDue){
        note.textContent="Ingen topics med due_date funnet i datagrunnlaget (grafen viser 0).";
        dueDateChart=buildBar(
          document.getElementById("dueDateChart").getContext("2d"),
          ["–"],
          [{label:"On-time",data:[0]},{label:"Late",data:[0]}],
          true
        );
      } else {
        note.textContent="Lukkede saker per uke: on-time (closed <= due_date) vs late (closed > due_date).";
        dueDateChart=buildBar(
          document.getElementById("dueDateChart").getContext("2d"),
          weekLabels,
          [{label:"On-time",data:dd.onTimeSeries},{label:"Late",data:dd.lateSeries}],
          true
        );
      }

      // NEW: CFD approx
      const cfd=aggregateCfdApprox(topicsToUse, weekLabels);
      cfdChart=destroyIf(cfdChart);
      cfdChart=buildCfd(
        document.getElementById("cfdChart").getContext("2d"),
        weekLabels,
        cfd.keys,
        cfd.seriesMap
      );

      // NEW: Aging per tag (open)
      const abt=aggregateAgingOpenBucketsByTag(topicsToUse, periodEndDate);
      agingByTagChart=destroyIf(agingByTagChart);
      agingByTagChart=buildStackedBar(
        document.getElementById("agingByTagChart").getContext("2d"),
        abt.tags,
        abt.buckets,
        abt.seriesMap
      );
    }

    function renderTopicDashboard(topicsToUse){
      // created total
      const totalAgg=aggregateCreatedTotal(topicsToUse);
      createdOverTimeChart=destroyIf(createdOverTimeChart);
      createdOverTimeChart=buildBar(
        document.getElementById("createdOverTimeChart").getContext("2d"),
        totalAgg.labels,
        [{label:"Opprettede topics",data:totalAgg.totals}],
        false
      );

      // lines
      const byStatus=aggregateCreatedByCategory(topicsToUse,t=>(t.topic_status||t.status));
      statusLineChart=destroyIf(statusLineChart);
      statusLineChart=buildMultiLine(document.getElementById("statusLineChart").getContext("2d"), byStatus.labels, byStatus.keys, byStatus.seriesMap);

      const byType=aggregateCreatedByCategory(topicsToUse,t=>(t.topic_type||t.type));
      typeLineChart=destroyIf(typeLineChart);
      typeLineChart=buildMultiLine(document.getElementById("typeLineChart").getContext("2d"), byType.labels, byType.keys, byType.seriesMap);

      const byPriority=aggregateCreatedByCategory(topicsToUse,t=>(t.priority));
      priorityLineChart=destroyIf(priorityLineChart);
      priorityLineChart=buildMultiLine(document.getElementById("priorityLineChart").getContext("2d"), byPriority.labels, byPriority.keys, byPriority.seriesMap);

      // tag pie + table
      const tagCounts=aggregateTagCounts(topicsToUse);
      tagDisciplineChart=destroyIf(tagDisciplineChart);
      tagDisciplineChart=buildPieWithCounts(document.getElementById("tagDisciplineChart").getContext("2d"), tagCounts);

      renderTagStatusTable(document.getElementById("tagStatusTableWrap"), aggregateTagStatusMatrix(topicsToUse));

      // avg cycle (creation bucket)
      const cycleAgg=aggregateAvgCycleTimeCreationBucket(topicsToUse);
      avgCycleTimeChart=destroyIf(avgCycleTimeChart);
      avgCycleTimeChart=buildLine(
        document.getElementById("avgCycleTimeChart").getContext("2d"),
        cycleAgg.labels,
        [
          {label:"Snitt per uke (dager)",data:cycleAgg.series,tension:0.25,pointRadius:2},
          {label:"Globalt snitt (dager)",data:cycleAgg.globalLine,tension:0,borderDash:[6,4],pointRadius:0}
        ]
      );
    }

    function renderAll(topicsFiltered){
      renderVdcDashboard(topicsFiltered);
      renderTopicDashboard(topicsFiltered);
    }

    async function refreshData(){
      setBusy(true);
      setError("");
      setStatus("Henter BCF Topics …", true);

      try{
        allTopics=await fetchTopics(currentProjectId);
        allTopicsWithDates=allTopics.filter(t=>!!parseDateMaybe(t.creation_date));

        if(!allTopicsWithDates.length){
          setError("Fant ingen topics med creation_date. Sjekk at BCF API returnerer creation_date i ditt miljø.");
          setStatus("Ingen data.");
          return;
        }

        populateWeekRangeSelectors(allTopicsWithDates);

        const filtered=filterTopicsByWeekRange(allTopicsWithDates);
        renderAll(filtered);

        setStatus(`Sist oppdatert: ${new Date().toLocaleString()} | Topics: ${filtered.length}/${allTopicsWithDates.length}`);
      } catch(err){
        console.error(err);
        setError("Feil ved henting av Topics: " + (err.message || err));
        setStatus("Klar, men med feil ved siste oppdatering.");
      } finally {
        setBusy(false);
      }
    }

    function handleAccessTokenPayload(payload){
      if(!payload) return;

      if(typeof payload==="string"){
        if(payload==="pending"||payload==="denied") return;
        accessToken=payload;
        refreshData();
        return;
      }

      if(typeof payload==="object"){
        if(payload.status==="denied"){
          setError("Tilgang til accessToken ble avslått i Trimble Connect-innstillinger.");
          setStatus("Kan ikke hente BCF Topics uten accessToken.");
        } else if(payload.accessToken){
          accessToken=payload.accessToken;
          refreshData();
        }
      }
    }

    async function init(){
      setError("");
      setStatus("Kobler til Trimble Connect …", true);

      try{
        API = await TrimbleConnectWorkspace.connect(window.parent, (event, args) => {
          if(event==="extension.accessToken") handleAccessTokenPayload(args.data);
        });

        const projectInfo = await API.project.getCurrentProject();
        currentProjectId = projectInfo.id;

        setStatus("Ber om tilgang til accessToken …", true);
        const permissionResult = await API.extension.requestPermission("accesstoken");
        handleAccessTokenPayload(permissionResult);

        if(permissionResult==="pending"){
          setStatus("Venter på at bruker godkjenner tilgang …", true);
        } else if(permissionResult==="denied"){
          setError("Tilgang til accessToken ble avslått i Trimble Connect-innstillinger.");
          setStatus("Kan ikke hente BCF Topics uten accessToken.");
        } else if(typeof permissionResult==="string"){
          accessToken=permissionResult;
          await refreshData();
        } else if(permissionResult && permissionResult.accessToken){
          accessToken=permissionResult.accessToken;
          await refreshData();
        } else {
          setStatus("Venter på accessToken …", true);
        }
      } catch(err){
        console.error(err);
        setError("Klarte ikke å koble til Trimble Connect Workspace API: " + (err.message || err));
        setStatus("Feil ved initialisering.");
      }
    }

    document.getElementById("applyWeekBtn").addEventListener("click", ()=>{
      if(!allTopicsWithDates.length) return;
      const filtered=filterTopicsByWeekRange(allTopicsWithDates);
      renderAll(filtered);

      const from=document.getElementById("fromWeekSelect").value;
      const to=document.getElementById("toWeekSelect").value;
      const label=(!from && !to) ? "Alle uker" : `Ukeintervall: ${from||"(start)"} → ${to||"(slutt)"}`;
      setStatus(`${label} | Topics: ${filtered.length}/${allTopicsWithDates.length}`);
    });

    document.getElementById("refreshBtn").addEventListener("click", refreshData);
    window.addEventListener("DOMContentLoaded", init);
  </script>
</body>
</html>
