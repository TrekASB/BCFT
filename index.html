<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>BCF Topic Stats</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Trimble Connect Workspace API -->
  <script src="https://components.connect.trimble.com/trimble-connect-workspace-api/index.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      display: flex;
      flex-direction: column;
      height: 100vh;
      background-color: #f5f5f5;
    }

    header {
      padding: 8px 12px;
      border-bottom: 1px solid #ddd;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 10px;
      background-color: #ffffff;
    }

    header h1 {
      font-size: 16px;
      margin: 0;
      font-weight: 600;
    }

    header .spacer { flex: 1; }

    button {
      padding: 6px 10px;
      border-radius: 4px;
      border: 1px solid #0078d4;
      background: #0078d4;
      color: #fff;
      font-size: 13px;
      cursor: pointer;
    }

    button.secondary {
      border: 1px solid #777;
      background: #777;
    }

    button:disabled {
      opacity: 0.6;
      cursor: default;
    }

    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 10px 12px 16px 12px;
      gap: 12px;
      overflow: auto;
    }

    #status { font-size: 13px; color: #444; }
    #error { font-size: 13px; color: #b00020; white-space: pre-wrap; }

    .cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 16px;
      align-items: stretch;
    }

    .card {
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
      padding: 10px 10px 14px 10px;
      display: flex;
      flex-direction: column;
      min-height: 200px;
    }

    .card h2 {
      margin: 0 0 8px 0;
      font-size: 14px;
      font-weight: 600;
    }

    .card p {
      margin: 0 0 6px 0;
      font-size: 13px;
    }

    .summary-value {
      font-size: 24px;
      font-weight: 700;
      line-height: 1.1;
    }

    .kpi-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 6px;
    }

    .kpi {
      border: 1px solid #eee;
      border-radius: 8px;
      padding: 8px;
      background: #fafafa;
    }

    .kpi .label { font-size: 12px; color: #666; margin-bottom: 2px; }
    .kpi .value { font-size: 18px; font-weight: 700; }

    canvas {
      width: 100% !important;
      height: 220px !important;
    }

    .small-text {
      font-size: 12px;
      color: #666;
      margin-top: 6px;
    }

    .loading-spinner {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid #ccc;
      border-top-color: #0078d4;
      animation: spin 0.8s linear infinite;
      margin-right: 6px;
    }

    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>
  <header>
    <h1>BCF Topic Stats</h1>
    <div class="spacer"></div>
    <button class="secondary" id="clearHistoryBtn" title="Sletter lagrede trend-data (lokalt i nettleser)">Tøm historikk</button>
    <button id="refreshBtn">Oppdater data</button>
  </header>

  <main>
    <div id="status">Initialiserer…</div>
    <div id="error"></div>

    <div class="cards">
      <div class="card">
        <h2>Oversikt</h2>
        <p>Antall BCF Topics i prosjektet:</p>
        <p id="totalTopics" class="summary-value">–</p>
        <p id="projectInfo" class="small-text"></p>

        <div class="kpi-grid">
          <div class="kpi">
            <div class="label">Åpne saker (nå)</div>
            <div class="value" id="openNow">–</div>
          </div>
          <div class="kpi">
            <div class="label">Lukkede saker (nå)</div>
            <div class="value" id="closedNow">–</div>
          </div>
          <div class="kpi">
            <div class="label">Median behandlingstid (dager)*</div>
            <div class="value" id="medianCycle">–</div>
          </div>
          <div class="kpi">
            <div class="label">Snitt behandlingstid (dager)*</div>
            <div class="value" id="avgCycle">–</div>
          </div>
        </div>

        <p class="small-text">
          * Behandlingstid = <code>modified_date - creation_date</code> for saker som tolkes som “lukkede”.
        </p>
      </div>

      <div class="card">
        <h2>Tidslinje</h2>
        <canvas id="timelineChart"></canvas>
        <p class="small-text">
          Basert på snapshot-logg (lokalt) + BCF feltene <code>creation_date</code>/<code>modified_date</code>. :contentReference[oaicite:2]{index=2}
        </p>
      </div>

      <div class="card">
        <h2>Topics per Type</h2>
        <canvas id="typeChart"></canvas>
        <p class="small-text">Basert på feltet <code>topic_type</code> (eller <code>type</code>).</p>
      </div>

      <div class="card">
        <h2>Topics per Priority</h2>
        <canvas id="priorityChart"></canvas>
        <p class="small-text">Typisk: Critical, High, Normal, Low.</p>
      </div>

      <div class="card">
        <h2>Topics per Status</h2>
        <canvas id="statusChart"></canvas>
        <p class="small-text">Basert på feltet <code>topic_status</code> (eller <code>status</code>).</p>
      </div>
    </div>
  </main>

  <script>
    let API = null;
    let accessToken = null;
    let currentProjectId = null;

    let typeChart = null;
    let priorityChart = null;
    let statusChart = null;
    let timelineChart = null;

    // Region-host
    const TOPICS_API_BASE = "https://open21.connect.trimble.com"; // <-- ENDRE VED BEHOV

    // Lokal historikk (trend)
    const HISTORY_KEY_PREFIX = "bcf_topic_stats_history__";
    function historyKey(projectId) { return HISTORY_KEY_PREFIX + projectId; }

    // Fargekart
    const STATUS_COLORS = {
      "New": "#3684D1",
      "In Progress": "#FCC603",
      "Waiting": "#29B35B",
      "Done": "#3684D1",
      "Closed": "#36B7D1",
      "Open": "#FCC603"
    };

    const PRIORITY_COLORS = {
      "Low": "#72A544",
      "Normal": "#005F9E",
      "High": "#FFBE00",
      "Critical": "#C81922"
    };

    const TYPE_COLORS = {
      "Issue": "#FF0000",
      "Clash": "#F908E9",
      "Request": "#FFFF00"
    };

    const DEFAULT_BAR_COLOR = "#999999";

    // Hvilke statuser tolkes som "lukket"
    const CLOSED_STATUSES = new Set(["Closed", "Done", "Resolved", "Approved"]);
    // Hvilke statuser tolkes som "åpen"
    const OPEN_STATUSES = new Set(["New", "Open", "In Progress", "Waiting", "ReOpened", "Reopen"]);

    function setStatus(message, isLoading = false) {
      const statusEl = document.getElementById("status");
      if (isLoading) statusEl.innerHTML = '<span class="loading-spinner"></span>' + message;
      else statusEl.textContent = message;
    }

    function setError(message) {
      document.getElementById("error").textContent = message || "";
    }

    function setBusy(isBusy) {
      document.getElementById("refreshBtn").disabled = isBusy;
      document.getElementById("clearHistoryBtn").disabled = isBusy;
    }

    function safeStr(v) {
      if (v === null || v === undefined) return "";
      return String(v).trim();
    }

    function parseDateMaybe(v) {
      const s = safeStr(v);
      if (!s) return null;
      const d = new Date(s);
      if (Number.isNaN(d.getTime())) return null;
      return d;
    }

    function toISODate(d) {
      // yyyy-mm-dd
      const year = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      return `${year}-${m}-${day}`;
    }

    function median(values) {
      if (!values.length) return null;
      const sorted = [...values].sort((a,b)=>a-b);
      const mid = Math.floor(sorted.length / 2);
      return (sorted.length % 2 !== 0) ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
    }

    function avg(values) {
      if (!values.length) return null;
      const sum = values.reduce((a,b)=>a+b, 0);
      return sum / values.length;
    }

    function countByKey(items, getter, emptyLabel = "Ikke satt") {
      const counts = {};
      for (const it of items) {
        const raw = getter(it);
        const key = (raw && String(raw).trim()) || emptyLabel;
        counts[key] = (counts[key] || 0) + 1;
      }
      return counts;
    }

    function buildBarChart(ctx, counts, colorMap) {
      const labels = Object.keys(counts);
      const data = labels.map(l => counts[l]);

      if (!labels.length) {
        return new Chart(ctx, {
          type: "bar",
          data: { labels: ["Ingen data"], datasets: [{ label: "Antall", data: [0] }] },
          options: {
            responsive: true,
            plugins: { legend: { display: false }, title: { display: false } },
            scales: { x: { ticks: { font: { size: 11 } } }, y: { beginAtZero: true, ticks: { precision: 0 } } }
          }
        });
      }

      const backgroundColors = labels.map(label => (colorMap && colorMap[label]) ? colorMap[label] : DEFAULT_BAR_COLOR);

      return new Chart(ctx, {
        type: "bar",
        data: {
          labels,
          datasets: [{
            label: "Antall Topics",
            data,
            backgroundColor: backgroundColors,
            borderColor: backgroundColors,
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: false },
            title: { display: false },
            tooltip: { callbacks: { label: (ctx) => `${ctx.parsed.y} topics` } }
          },
          scales: {
            x: { ticks: { font: { size: 11 }, autoSkip: false, maxRotation: 45, minRotation: 0 } },
            y: { beginAtZero: true, ticks: { precision: 0 } }
          }
        }
      });
    }

    function buildTimelineChart(ctx, points) {
      // points: [{date:"yyyy-mm-dd", openCount, newCount}]
      const labels = points.map(p => p.date);
      const openData = points.map(p => p.openCount);
      const newData = points.map(p => p.newCount);

      if (!labels.length) {
        return new Chart(ctx, {
          type: "line",
          data: { labels: ["Ingen historikk"], datasets: [{ label: "Åpne", data: [0] }] },
          options: { responsive: true, plugins: { legend: { display: false } } }
        });
      }

      return new Chart(ctx, {
        type: "line",
        data: {
          labels,
          datasets: [
            { label: "Åpne saker (snapshot)", data: openData, tension: 0.25 },
            { label: "Nye saker (siste døgn/uke)", data: newData, tension: 0.25 }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: true },
            tooltip: { callbacks: { label: (ctx) => `${ctx.dataset.label}: ${ctx.parsed.y}` } }
          },
          scales: {
            x: { ticks: { maxRotation: 45, minRotation: 0, autoSkip: true } },
            y: { beginAtZero: true, ticks: { precision: 0 } }
          }
        }
      });
    }

    async function fetchTopics(projectId) {
      if (!accessToken) throw new Error("Mangler accessToken – kunne ikke hente Topics.");

      const url = `${TOPICS_API_BASE}/bcf/3.0/projects/${encodeURIComponent(projectId)}/topics`;

      const resp = await fetch(url, {
        method: "GET",
        headers: { "Authorization": `Bearer ${accessToken}`, "Accept": "application/json" }
      });

      if (!resp.ok) {
        const text = await resp.text().catch(() => "");
        throw new Error(`Topics API-feil (${resp.status}): ${text || resp.statusText}`);
      }

      const json = await resp.json();
      if (!Array.isArray(json)) {
        console.warn("Uventet responsformat fra Topics API:", json);
        return [];
      }
      return json;
    }

    // ---- Trend / snapshot-historikk ----
    function loadHistory(projectId) {
      try {
        const raw = localStorage.getItem(historyKey(projectId));
        if (!raw) return [];
        const arr = JSON.parse(raw);
        if (!Array.isArray(arr)) return [];
        return arr;
      } catch {
        return [];
      }
    }

    function saveHistory(projectId, historyArr) {
      localStorage.setItem(historyKey(projectId), JSON.stringify(historyArr));
    }

    function upsertSnapshot(projectId, snapshot) {
      const history = loadHistory(projectId);

      // Vi lagrer per dato (yyyy-mm-dd). Hvis du vil ha flere datapunkter per dag, bytt key til timestamp.
      const idx = history.findIndex(x => x.date === snapshot.date);
      if (idx >= 0) history[idx] = snapshot;
      else history.push(snapshot);

      history.sort((a,b) => a.date.localeCompare(b.date));
      saveHistory(projectId, history);
      return history;
    }

    function clearHistory(projectId) {
      localStorage.removeItem(historyKey(projectId));
    }

    function computeNewTopicsSince(topics, sinceDate) {
      // teller topics opprettet >= sinceDate
      let count = 0;
      for (const t of topics) {
        const cd = parseDateMaybe(t.creation_date);
        if (cd && cd >= sinceDate) count++;
      }
      return count;
    }

    function computeOpenClosed(topics) {
      let open = 0, closed = 0;
      for (const t of topics) {
        const st = safeStr(t.topic_status || t.status) || "Ikke satt";
        if (CLOSED_STATUSES.has(st)) closed++;
        else if (OPEN_STATUSES.has(st)) open++;
        else {
          // fallback: ukjent status -> regn som åpen, men du kan endre
          open++;
        }
      }
      return { open, closed };
    }

    function computeCycleTimesDays(topics) {
      // For "lukkede" topics: (modified_date - creation_date)
      const days = [];
      for (const t of topics) {
        const st = safeStr(t.topic_status || t.status);
        if (!CLOSED_STATUSES.has(st)) continue;

        const cd = parseDateMaybe(t.creation_date);
        const md = parseDateMaybe(t.modified_date);
        if (!cd || !md) continue;

        const diffMs = md.getTime() - cd.getTime();
        if (diffMs < 0) continue;

        const diffDays = diffMs / (1000 * 60 * 60 * 24);
        days.push(diffDays);
      }
      return days;
    }

    function updateCharts(topics) {
      const total = topics.length;
      document.getElementById("totalTopics").textContent = String(total);

      // Status / type / priority
      const typeCounts = countByKey(topics, t => t.topic_type || t.type, "Ikke satt");
      const priorityCounts = countByKey(topics, t => t.priority, "Ikke satt");
      const statusCounts = countByKey(topics, t => t.topic_status || t.status, "Ikke satt");

      if (typeChart) typeChart.destroy();
      if (priorityChart) priorityChart.destroy();
      if (statusChart) statusChart.destroy();

      typeChart = buildBarChart(document.getElementById("typeChart").getContext("2d"), typeCounts, TYPE_COLORS);
      priorityChart = buildBarChart(document.getElementById("priorityChart").getContext("2d"), priorityCounts, PRIORITY_COLORS);
      statusChart = buildBarChart(document.getElementById("statusChart").getContext("2d"), statusCounts, STATUS_COLORS);

      // KPI: open/closed + cycle time
      const oc = computeOpenClosed(topics);
      document.getElementById("openNow").textContent = String(oc.open);
      document.getElementById("closedNow").textContent = String(oc.closed);

      const cycleDays = computeCycleTimesDays(topics);
      const med = median(cycleDays);
      const av = avg(cycleDays);
      document.getElementById("medianCycle").textContent = (med === null) ? "–" : String(Math.round(med));
      document.getElementById("avgCycle").textContent = (av === null) ? "–" : String(Math.round(av));

      // Timeline (snapshot-trend)
      const today = new Date();
      const todayKey = toISODate(today);

      // "Nye saker siden i går" (du kan bytte til 7 dager for uke-trend)
      const since = new Date(today.getTime() - 24 * 60 * 60 * 1000);
      const newSince = computeNewTopicsSince(topics, since);

      const snapshot = {
        date: todayKey,
        openCount: oc.open,
        closedCount: oc.closed,
        totalCount: total,
        newCount: newSince
      };

      const history = upsertSnapshot(currentProjectId, snapshot);

      if (timelineChart) timelineChart.destroy();
      timelineChart = buildTimelineChart(
        document.getElementById("timelineChart").getContext("2d"),
        history.map(h => ({ date: h.date, openCount: h.openCount, newCount: h.newCount }))
      );
    }

    async function refreshData() {
      if (!currentProjectId) {
        setError("Mangler projectId – er extensionen lastet i et Trimble Connect-prosjekt?");
        return;
      }

      setBusy(true);
      setStatus("Henter BCF Topics …", true);
      setError("");

      try {
        const topics = await fetchTopics(currentProjectId);
        updateCharts(topics);
        setStatus(`Sist oppdatert: ${new Date().toLocaleString()}`);
      } catch (err) {
        console.error(err);
        setError("Feil ved henting av Topics: " + (err.message || err));
        setStatus("Klar, men med feil ved siste oppdatering.");
      } finally {
        setBusy(false);
      }
    }

    function handleAccessTokenPayload(payload) {
      if (!payload) return;

      if (typeof payload === "string") {
        if (payload === "pending" || payload === "denied") return;
        accessToken = payload;
        refreshData();
        return;
      }

      if (typeof payload === "object") {
        if (payload.status === "denied") {
          setError("Tilgang til accessToken ble avslått i Trimble Connect-innstillinger.");
          setStatus("Kan ikke hente BCF Topics uten accessToken.");
        } else if (payload.accessToken) {
          accessToken = payload.accessToken;
          refreshData();
        }
      }
    }

    async function init() {
      setStatus("Kobler til Trimble Connect …", true);
      setError("");

      try {
        API = await TrimbleConnectWorkspace.connect(window.parent, (event, args) => {
          switch (event) {
            case "extension.accessToken":
              handleAccessTokenPayload(args.data);
              break;
            default:
              break;
          }
        });

        const projectInfo = await API.project.getCurrentProject();
        currentProjectId = projectInfo.id;

        document.getElementById("projectInfo").textContent =
          `Prosjekt: ${projectInfo.name} (ID: ${projectInfo.id})`;

        setStatus("Ber om tilgang til accessToken …", true);
        const permissionResult = await API.extension.requestPermission("accesstoken");
        handleAccessTokenPayload(permissionResult);

        if (permissionResult === "pending") {
          setStatus("Venter på at bruker godkjenner tilgang i Trimble Connect …", true);
        } else if (permissionResult === "denied") {
          setError("Tilgang til accessToken ble avslått i Trimble Connect-innstillinger.");
          setStatus("Kan ikke hente BCF Topics uten accessToken.");
        } else if (typeof permissionResult === "string") {
          accessToken = permissionResult;
          await refreshData();
        } else if (permissionResult && permissionResult.accessToken) {
          accessToken = permissionResult.accessToken;
          await refreshData();
        } else {
          setStatus("Venter på accessToken fra Trimble Connect …", true);
        }
      } catch (err) {
        console.error(err);
        setError("Klarte ikke å koble til Trimble Connect Workspace API: " + (err.message || err));
        setStatus("Feil ved initialisering.");
      }
    }

    document.getElementById("refreshBtn").addEventListener("click", refreshData);

    document.getElementById("clearHistoryBtn").addEventListener("click", () => {
      if (!currentProjectId) return;
      clearHistory(currentProjectId);
      if (timelineChart) timelineChart.destroy();
      timelineChart = buildTimelineChart(
        document.getElementById("timelineChart").getContext("2d"),
        []
      );
      setStatus("Historikk tømt (lokalt). Oppdater data for å bygge trend på nytt.");
    });

    window.addEventListener("DOMContentLoaded", init);
  </script>
</body>
</html>
