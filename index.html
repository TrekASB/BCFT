<!DOCTYPE html>
<html lang="nb">
<head>
  <meta charset="UTF-8" />
  <title>BCF Topic Stats</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Trimble Connect Workspace API -->
  <script src="https://components.connect.trimble.com/trimble-connect-workspace-api/index.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    :root{
      --primary:#0069d9;
      --border:#e5e7eb;
      --card:#ffffff;
      --bg:#f5f5f7;
      --text:#111827;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body{ margin:0; background:var(--bg); color:var(--text); min-height:100vh; display:flex; flex-direction:column; }

    header{
      display:flex; align-items:center; gap:14px;
      padding:12px 14px; background:var(--card); border-bottom:1px solid var(--border);
    }
    .logoBox{
      width:92px; height:92px; border-radius:12px; background:#fff; border:1px solid #eee;
      display:flex; align-items:center; justify-content:center; overflow:hidden;
      box-shadow:0 1px 3px rgba(15,23,42,.08); flex:0 0 auto;
    }
    .logoBox img{ width:84px; height:84px; object-fit:contain; display:block; }

    .titleBlock{ display:flex; flex-direction:column; gap:2px; }
    .title{ font-weight:800; font-size:18px; color:var(--primary); line-height:1.1; }
    .org{ font-weight:700; font-size:13px; opacity:.9; }
    .dev{ font-size:11px; opacity:.75; font-style:italic; }

    .headerRight{
      margin-left:auto; display:flex; align-items:center; gap:10px; flex-wrap:wrap; justify-content:flex-end;
    }
    #status{
      font-size:12px; opacity:.85; white-space:nowrap; max-width:520px; overflow:hidden; text-overflow:ellipsis;
    }

    button{
      padding:8px 10px; border-radius:8px; border:1px solid var(--primary);
      background:var(--primary); color:#fff; font-size:13px; font-weight:600; cursor:pointer;
      box-shadow:0 1px 2px rgba(0,0,0,.08);
    }
    button.secondary{ border:1px solid #777; background:#777; }
    button:disabled{ opacity:.6; cursor:default; }

    .loading-spinner{
      display:inline-block; width:12px; height:12px; border-radius:50%;
      border:2px solid #ccc; border-top-color:var(--primary);
      animation:spin .8s linear infinite; margin-right:6px; vertical-align:-2px;
    }
    @keyframes spin{ to{ transform:rotate(360deg);} }

    main{
      flex:1; display:flex; flex-direction:column; padding:12px 14px 18px 14px; gap:12px; overflow:auto;
    }
    #error{ font-size:13px; color:#b00020; white-space:pre-wrap; }

    /* Linje mellom grafer */
    .cards{
      display:grid;
      grid-template-columns:repeat(auto-fit, minmax(360px, 1fr));
      gap:0;
      border:1px solid var(--border);
      border-radius:14px;
      overflow:hidden;
      background:var(--card);
    }
    .card{
      background:var(--card);
      padding:12px 12px 14px 12px;
      display:flex;
      flex-direction:column;
      min-height:280px;
      border-right:1px solid var(--border);
      border-bottom:1px solid var(--border);
    }
    .card h2{ margin:0 0 8px 0; font-size:14px; font-weight:800; }
    .divider{ height:1px; background:var(--border); margin:8px 0 10px 0; }
    .small-text{ font-size:12px; color:#6b7280; margin-top:8px; }
    canvas{ width:100% !important; height:280px !important; }

    /* Filter */
    .filterRow{
      display:flex;
      gap:10px;
      align-items:flex-end;
      flex-wrap:wrap;
      padding:10px 12px;
      background:var(--card);
      border:1px solid var(--border);
      border-radius:14px;
    }
    .field{ display:flex; flex-direction:column; gap:4px; }
    .field label{ font-size:12px; color:#6b7280; font-weight:700; }
    select{
      padding:8px 10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#fff;
      font-size:13px;
      min-width:220px;
    }
    .hint{ font-size:12px; color:#6b7280; margin-left:auto; }
  </style>
</head>

<body>
  <header>
    <div class="logoBox">
      <img src="norconsult-logo-black.png" alt="Norconsult logo"
           onerror="this.style.display='none'; this.parentElement.textContent='Norconsult'; this.parentElement.style.fontWeight='900';">
    </div>

    <div class="titleBlock">
      <div class="title">BCF Topic Stats</div>
      <div class="org">Norconsult Norge</div>
      <div class="dev">Developed by Edin Dzakmic, Norconsult, (AI-assisted development)</div>
    </div>

    <div class="headerRight">
      <div id="status"><span class="loading-spinner"></span>Kobler til Trimble Connect…</div>
      <button id="refreshBtn">Oppdater data</button>
    </div>
  </header>

  <main>
    <div id="error"></div>

    <!-- Velg fra/til uke -->
    <div class="filterRow">
      <div class="field">
        <label for="fromWeekSelect">Fra uke</label>
        <select id="fromWeekSelect">
          <option value="">(ingen)</option>
        </select>
      </div>

      <div class="field">
        <label for="toWeekSelect">Til uke</label>
        <select id="toWeekSelect">
          <option value="">(ingen)</option>
        </select>
      </div>

      <button class="secondary" id="applyWeekBtn" title="Tegner grafer for valgt ukeintervall">Bruk ukeintervall</button>

      <div class="hint">
        Hvis “Fra” og “Til” er tomme → alle uker.
      </div>
    </div>

    <div class="cards">
      <div class="card">
        <h2>Opprettede Topics over tid</h2>
        <div class="divider"></div>
        <canvas id="createdOverTimeChart"></canvas>
        <div class="small-text">Bygger på <code>creation_date</code> (gruppe per uke).</div>
      </div>

      <div class="card">
        <h2>Topics per Status over tid (linje)</h2>
        <div class="divider"></div>
        <canvas id="statusLineChart"></canvas>
        <div class="small-text">Linjer per status (antall opprettet per uke).</div>
      </div>

      <div class="card">
        <h2>Topics per Type over tid (linje)</h2>
        <div class="divider"></div>
        <canvas id="typeLineChart"></canvas>
        <div class="small-text">Linjer per type (antall opprettet per uke).</div>
      </div>

      <div class="card">
        <h2>Topics per Priority over tid (linje)</h2>
        <div class="divider"></div>
        <canvas id="priorityLineChart"></canvas>
        <div class="small-text">Linjer per priority (antall opprettet per uke).</div>
      </div>

      <div class="card">
        <h2>Fordeling per fag (Tag)</h2>
        <div class="divider"></div>
        <canvas id="tagDisciplineChart"></canvas>
        <div class="small-text">
          Basert på tag (f.eks. “Veg”, “VAO”, osv.). Hvis flere tags finnes på samme topic kan den telle flere ganger.
        </div>
      </div>

      <div class="card">
        <h2>Gjennomsnittlig tid fra opprettet → lukket</h2>
        <div class="divider"></div>
        <canvas id="avgCycleTimeChart"></canvas>
        <div class="small-text">
          For topics med status <code>Closed/Done/Resolved/Approved</code>: <code>modified_date - creation_date</code> i dager.
        </div>
      </div>
    </div>
  </main>

  <script>
    // ====== KONFIG ======
    const TOPICS_API_BASE = "https://open21.connect.trimble.com";
    const GROUP_BY = "week";

    const CLOSED_STATUSES = new Set(["Closed", "Done", "Resolved", "Approved"]);
    const UNKNOWN_LABEL = "Ikke satt";

    // (Valgfritt) farger
    const STATUS_COLORS = {
      "New": "#3684D1",
      "Open": "#FCC603",
      "In Progress": "#FCC603",
      "Waiting": "#29B35B",
      "Done": "#36B7D1",
      "Closed": "#36B7D1"
    };
    const TYPE_COLORS = { "Issue": "#FF0000", "Clash": "#F908E9", "Request": "#FFFF00" };
    const PRIORITY_COLORS = { "Low": "#72A544", "Normal": "#005F9E", "Medium": "#005F9E", "High": "#FFBE00", "Critical": "#C81922" };

    // ====== STATE ======
    let API = null;
    let accessToken = null;
    let currentProjectId = null;

    let createdOverTimeChart = null;
    let statusLineChart = null;
    let typeLineChart = null;
    let priorityLineChart = null;
    let tagDisciplineChart = null;
    let avgCycleTimeChart = null;

    let allTopics = [];
    let allTopicsWithDates = [];

    // ====== HELPERS ======
    function escapeHtml(str) {
      return String(str ?? "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }
    function setStatus(message, isLoading = false) {
      const el = document.getElementById("status");
      el.innerHTML = isLoading
        ? `<span class="loading-spinner"></span>${escapeHtml(message)}`
        : escapeHtml(message);
    }
    function setError(message) { document.getElementById("error").textContent = message || ""; }
    function setBusy(isBusy) { document.getElementById("refreshBtn").disabled = isBusy; }

    function safeStr(v) { return (v === null || v === undefined) ? "" : String(v).trim(); }
    function parseDateMaybe(v) {
      const s = safeStr(v);
      if (!s) return null;
      const d = new Date(s);
      return Number.isNaN(d.getTime()) ? null : d;
    }
    function pad2(n){ return String(n).padStart(2,"0"); }

    // ISO week key: YYYY-Www
    function getISOWeekKey(date) {
      const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
      const dayNum = d.getUTCDay() || 7;
      d.setUTCDate(d.getUTCDate() + 4 - dayNum);
      const yearStart = new Date(Date.UTC(d.getUTCFullYear(),0,1));
      const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
      return `${d.getUTCFullYear()}-W${pad2(weekNo)}`;
    }
    function bucketKey(date) { return getISOWeekKey(date); }

    function uniqueSorted(arr) {
      return [...new Set(arr)].sort((a,b) => a.localeCompare(b));
    }

    function avg(nums) {
      const v = nums.filter(n => Number.isFinite(n));
      if (!v.length) return null;
      return v.reduce((a,b)=>a+b,0) / v.length;
    }

    function compareWeekKeys(a, b) {
      // a/b: "YYYY-Www"
      // Lexicographic works because fixed format, but we ensure:
      return a.localeCompare(b);
    }

    // ====== FILTER: fra/til uke ======
    function populateWeekRangeSelectors(topics) {
      const weeks = [];
      for (const t of topics) {
        const cd = parseDateMaybe(t.creation_date);
        if (!cd) continue;
        weeks.push(bucketKey(cd));
      }
      const uniqueWeeks = uniqueSorted(weeks);

      const fromSel = document.getElementById("fromWeekSelect");
      const toSel = document.getElementById("toWeekSelect");
      const prevFrom = fromSel.value;
      const prevTo = toSel.value;

      fromSel.innerHTML = `<option value="">(ingen)</option>` + uniqueWeeks.map(w => `<option value="${escapeHtml(w)}">${escapeHtml(w)}</option>`).join("");
      toSel.innerHTML = `<option value="">(ingen)</option>` + uniqueWeeks.map(w => `<option value="${escapeHtml(w)}">${escapeHtml(w)}</option>`).join("");

      if (prevFrom && uniqueWeeks.includes(prevFrom)) fromSel.value = prevFrom;
      if (prevTo && uniqueWeeks.includes(prevTo)) toSel.value = prevTo;
    }

    function filterTopicsByWeekRange(topics) {
      const from = document.getElementById("fromWeekSelect").value; // may be ""
      const to = document.getElementById("toWeekSelect").value;     // may be ""
      if (!from && !to) return topics;

      return topics.filter(t => {
        const cd = parseDateMaybe(t.creation_date);
        if (!cd) return false;
        const wk = bucketKey(cd);

        if (from && compareWeekKeys(wk, from) < 0) return false;
        if (to && compareWeekKeys(wk, to) > 0) return false;
        return true;
      });
    }

    // ====== DATA AGGREGATION (basert på creation_date) ======
    function aggregateCreatedTotal(topics) {
      const buckets = [];
      const bucketMap = new Map(); // b -> count

      for (const t of topics) {
        const cd = parseDateMaybe(t.creation_date);
        if (!cd) continue;
        const b = bucketKey(cd);
        buckets.push(b);
        bucketMap.set(b, (bucketMap.get(b) || 0) + 1);
      }

      const labels = uniqueSorted(buckets);
      const totals = labels.map(b => bucketMap.get(b) || 0);
      return { labels, totals };
    }

    function aggregateCreatedByCategory(topics, getCategory) {
      const buckets = [];
      const bucketMap = new Map(); // b -> {cat:count}

      for (const t of topics) {
        const cd = parseDateMaybe(t.creation_date);
        if (!cd) continue;
        const b = bucketKey(cd);
        buckets.push(b);

        const cat = safeStr(getCategory(t)) || UNKNOWN_LABEL;

        if (!bucketMap.has(b)) bucketMap.set(b, {});
        const obj = bucketMap.get(b);
        obj[cat] = (obj[cat] || 0) + 1;
      }

      const labels = uniqueSorted(buckets);

      const keySet = new Set();
      for (const b of labels) {
        const obj = bucketMap.get(b) || {};
        Object.keys(obj).forEach(k => keySet.add(k));
      }
      const keys = [...keySet].sort((a,b)=>a.localeCompare(b));

      const seriesMap = {};
      for (const k of keys) seriesMap[k] = labels.map(b => (bucketMap.get(b)?.[k] || 0));
      return { labels, keys, seriesMap };
    }

    function aggregateAvgCycleTime(topics) {
      const bucketMap = new Map(); // bucket -> [days...]
      const allDays = [];

      for (const t of topics) {
        const st = safeStr(t.topic_status || t.status);
        if (!CLOSED_STATUSES.has(st)) continue;

        const cd = parseDateMaybe(t.creation_date);
        const md = parseDateMaybe(t.modified_date);
        if (!cd || !md) continue;

        const diffMs = md.getTime() - cd.getTime();
        if (diffMs < 0) continue;

        const days = diffMs / (1000*60*60*24);
        allDays.push(days);

        const b = bucketKey(cd);
        if (!bucketMap.has(b)) bucketMap.set(b, []);
        bucketMap.get(b).push(days);
      }

      const labels = uniqueSorted([...bucketMap.keys()]);
      const series = labels.map(b => {
        const a = avg(bucketMap.get(b) || []);
        return a === null ? null : Math.round(a);
      });

      const globalAvg = avg(allDays);
      const globalLine = labels.map(_ => globalAvg === null ? null : Math.round(globalAvg));
      return { labels, series, globalLine };
    }

    // ====== TAG / FAG ======
    function extractTags(topic) {
      // BCF 3.0 kan ha "labels" (array). Noen APIer bruker "tags" eller "label".
      // Vi sjekker flere muligheter robust:
      const candidates = [];

      if (Array.isArray(topic.labels)) candidates.push(...topic.labels);
      if (Array.isArray(topic.tags)) candidates.push(...topic.tags);

      const single = safeStr(topic.label || topic.tag || topic.discipline);
      if (single) candidates.push(single);

      // normaliser, fjern tomme, unike
      return [...new Set(candidates.map(safeStr).filter(Boolean))];
    }

    function aggregateDisciplineByTag(topics) {
      // teller topics per tag (innenfor filtrert periode)
      const counts = {};
      for (const t of topics) {
        const tags = extractTags(t);
        if (!tags.length) {
          counts[UNKNOWN_LABEL] = (counts[UNKNOWN_LABEL] || 0) + 1;
          continue;
        }

        // Du kan velge "tell kun første tag" hvis du vil:
        // const first = tags[0]; counts[first] = (counts[first]||0)+1;
        // Her teller vi alle tags på topic:
        for (const tag of tags) {
          counts[tag] = (counts[tag] || 0) + 1;
        }
      }
      return counts;
    }

    // ====== CHART HELPERS ======
    function destroyIf(c){ if (c) c.destroy(); return null; }

    function buildCreatedOverTime(ctx, labels, totals) {
      return new Chart(ctx, {
        type: "bar",
        data: { labels, datasets: [{ label: "Opprettede topics", data: totals }] },
        options: {
          responsive: true,
          plugins: { legend: { display: true } },
          scales: {
            x: { ticks: { maxRotation: 45, minRotation: 0, autoSkip: true } },
            y: { beginAtZero: true, ticks: { precision: 0 } }
          }
        }
      });
    }

    function buildMultiLine(ctx, labels, keys, seriesMap, colorMap, legendTitle) {
      const datasets = keys.map(k => ({
        label: k,
        data: seriesMap[k],
        tension: 0.25,
        borderColor: (colorMap && colorMap[k]) ? colorMap[k] : undefined,
        pointRadius: 2
      }));

      return new Chart(ctx, {
        type: "line",
        data: { labels, datasets },
        options: {
          responsive: true,
          plugins: { legend: { display: true, title: { display: !!legendTitle, text: legendTitle || "" } } },
          scales: {
            x: { ticks: { maxRotation: 45, minRotation: 0, autoSkip: true } },
            y: { beginAtZero: true, ticks: { precision: 0 } }
          }
        }
      });
    }

    function buildPie(ctx, counts) {
      const labels = Object.keys(counts);
      const data = labels.map(l => counts[l]);

      return new Chart(ctx, {
        type: "pie",
        data: { labels, datasets: [{ data }] },
        options: {
          responsive: true,
          plugins: { legend: { display: true } }
        }
      });
    }

    function buildAvgCycle(ctx, labels, series, globalLine) {
      return new Chart(ctx, {
        type: "line",
        data: {
          labels,
          datasets: [
            { label: "Snitt per uke (dager)", data: series, tension: 0.25, pointRadius: 2 },
            { label: "Globalt snitt (dager)", data: globalLine, tension: 0, borderDash: [6,4], pointRadius: 0 }
          ]
        },
        options: {
          responsive: true,
          plugins: { legend: { display: true } },
          scales: {
            x: { ticks: { maxRotation: 45, minRotation: 0, autoSkip: true } },
            y: { beginAtZero: true, ticks: { precision: 0 } }
          }
        }
      });
    }

    // ====== API ======
    async function fetchTopics(projectId) {
      if (!accessToken) throw new Error("Mangler accessToken – kunne ikke hente Topics.");
      const url = `${TOPICS_API_BASE}/bcf/3.0/projects/${encodeURIComponent(projectId)}/topics`;

      const resp = await fetch(url, {
        method: "GET",
        headers: { "Authorization": `Bearer ${accessToken}`, "Accept": "application/json" }
      });

      if (!resp.ok) {
        const text = await resp.text().catch(() => "");
        throw new Error(`Topics API-feil (${resp.status}): ${text || resp.statusText}`);
      }

      const json = await resp.json();
      return Array.isArray(json) ? json : [];
    }

    // ====== RENDER ======
    function renderAllCharts(topicsToUse) {
      // Total created over time
      const totalAgg = aggregateCreatedTotal(topicsToUse);
      createdOverTimeChart = destroyIf(createdOverTimeChart);
      createdOverTimeChart = buildCreatedOverTime(
        document.getElementById("createdOverTimeChart").getContext("2d"),
        totalAgg.labels,
        totalAgg.totals
      );

      // Multi-line: status / type / priority (kun linjer, ingen stolper)
      const byStatus = aggregateCreatedByCategory(topicsToUse, t => (t.topic_status || t.status));
      statusLineChart = destroyIf(statusLineChart);
      statusLineChart = buildMultiLine(
        document.getElementById("statusLineChart").getContext("2d"),
        byStatus.labels,
        byStatus.keys,
        byStatus.seriesMap,
        STATUS_COLORS,
        "Status"
      );

      const byType = aggregateCreatedByCategory(topicsToUse, t => (t.topic_type || t.type));
      typeLineChart = destroyIf(typeLineChart);
      typeLineChart = buildMultiLine(
        document.getElementById("typeLineChart").getContext("2d"),
        byType.labels,
        byType.keys,
        byType.seriesMap,
        TYPE_COLORS,
        "Type"
      );

      const byPriority = aggregateCreatedByCategory(topicsToUse, t => (t.priority));
      priorityLineChart = destroyIf(priorityLineChart);
      priorityLineChart = buildMultiLine(
        document.getElementById("priorityLineChart").getContext("2d"),
        byPriority.labels,
        byPriority.keys,
        byPriority.seriesMap,
        PRIORITY_COLORS,
        "Priority"
      );

      // Tag / fag pie
      const tagCounts = aggregateDisciplineByTag(topicsToUse);
      tagDisciplineChart = destroyIf(tagDisciplineChart);
      tagDisciplineChart = buildPie(
        document.getElementById("tagDisciplineChart").getContext("2d"),
        tagCounts
      );

      // Avg cycle time
      const cycleAgg = aggregateAvgCycleTime(topicsToUse);
      avgCycleTimeChart = destroyIf(avgCycleTimeChart);
      avgCycleTimeChart = buildAvgCycle(
        document.getElementById("avgCycleTimeChart").getContext("2d"),
        cycleAgg.labels,
        cycleAgg.series,
        cycleAgg.globalLine
      );
    }

    async function refreshData() {
      setBusy(true);
      setError("");
      setStatus("Henter BCF Topics …", true);

      try {
        allTopics = await fetchTopics(currentProjectId);
        allTopicsWithDates = allTopics.filter(t => !!parseDateMaybe(t.creation_date));

        if (!allTopicsWithDates.length) {
          setError("Fant ingen topics med creation_date. Sjekk at BCF API returnerer creation_date i ditt miljø.");
          setStatus("Ingen data.");
          return;
        }

        populateWeekRangeSelectors(allTopicsWithDates);

        // Default: alle uker
        renderAllCharts(allTopicsWithDates);

        setStatus(`Sist oppdatert: ${new Date().toLocaleString()} | Topics: ${allTopicsWithDates.length}`);
      } catch (err) {
        console.error(err);
        setError("Feil ved henting av Topics: " + (err.message || err));
        setStatus("Klar, men med feil ved siste oppdatering.");
      } finally {
        setBusy(false);
      }
    }

    function handleAccessTokenPayload(payload) {
      if (!payload) return;

      if (typeof payload === "string") {
        if (payload === "pending" || payload === "denied") return;
        accessToken = payload;
        refreshData();
        return;
      }

      if (typeof payload === "object") {
        if (payload.status === "denied") {
          setError("Tilgang til accessToken ble avslått i Trimble Connect-innstillinger.");
          setStatus("Kan ikke hente BCF Topics uten accessToken.");
        } else if (payload.accessToken) {
          accessToken = payload.accessToken;
          refreshData();
        }
      }
    }

    async function init() {
      setError("");
      setStatus("Kobler til Trimble Connect …", true);

      try {
        API = await TrimbleConnectWorkspace.connect(window.parent, (event, args) => {
          if (event === "extension.accessToken") {
            handleAccessTokenPayload(args.data);
          }
        });

        const projectInfo = await API.project.getCurrentProject();
        currentProjectId = projectInfo.id;

        setStatus("Ber om tilgang til accessToken …", true);
        const permissionResult = await API.extension.requestPermission("accesstoken");
        handleAccessTokenPayload(permissionResult);

        if (permissionResult === "pending") {
          setStatus("Venter på at bruker godkjenner tilgang …", true);
        } else if (permissionResult === "denied") {
          setError("Tilgang til accessToken ble avslått i Trimble Connect-innstillinger.");
          setStatus("Kan ikke hente BCF Topics uten accessToken.");
        } else if (typeof permissionResult === "string") {
          accessToken = permissionResult;
          await refreshData();
        } else if (permissionResult && permissionResult.accessToken) {
          accessToken = permissionResult.accessToken;
          await refreshData();
        } else {
          setStatus("Venter på accessToken …", true);
        }
      } catch (err) {
        console.error(err);
        setError("Klarte ikke å koble til Trimble Connect Workspace API: " + (err.message || err));
        setStatus("Feil ved initialisering.");
      }
    }

    // Ukeintervall knapp
    document.getElementById("applyWeekBtn").addEventListener("click", () => {
      if (!allTopicsWithDates.length) return;
      const filtered = filterTopicsByWeekRange(allTopicsWithDates);
      renderAllCharts(filtered);

      const from = document.getElementById("fromWeekSelect").value;
      const to = document.getElementById("toWeekSelect").value;

      const label = (!from && !to) ? "Alle uker" : `Ukeintervall: ${from || "(start)"} → ${to || "(slutt)"}`;
      setStatus(`${label} | Topics: ${filtered.length}`);
    });

    document.getElementById("refreshBtn").addEventListener("click", refreshData);
    window.addEventListener("DOMContentLoaded", init);
  </script>
</body>
</html>
